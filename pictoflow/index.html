<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>PictoFlow</title>
<style>
body { user-select: none; -webkit-user-select: none; -ms-user-select: none; font-family: sans-serif; }
#planning { min-height: 100px; border:1px solid black; padding:10px; margin-bottom:10px; }
#editor { display:none; border:1px solid black; padding:10px; max-height:400px; overflow-y:auto; }
#searchResults { display:flex; flex-wrap:wrap; gap:5px; max-height:300px; overflow-y:auto; margin-top:5px; border:1px solid #ccc; padding:5px; }
img { cursor:pointer; }
.dragging { opacity:0.4; }
</style>
</head>
<body>

<button id="toggleEditorBtn">Open Editor</button>

<div id="planning">
<h2>Planning</h2>
<p>Drag images here to create or reorder your plan.</p>
</div>

<div id="editor">
<h2>Search Pictos</h2>
<input type="text" id="searchBar" placeholder="Search pictos..." style="width:100%; padding:5px;">
<div id="searchResults"></div>
</div>

<script>
let pictoIndex = [];
let draggedItem = null;

// ---------- Load JSON ----------
fetch("index.json")
  .then(res => res.json())
  .then(data => pictoIndex = data)
  .catch(err => console.error("Could not load pictos:", err));

// ---------- Toggle Editor ----------
const editor = document.getElementById("editor");
const toggleBtn = document.getElementById("toggleEditorBtn");
toggleBtn.addEventListener("click", () => {
    if (editor.style.display === "none") {
        editor.style.display = "block";
        toggleBtn.textContent = "Close Editor";
    } else {
        editor.style.display = "none";
        toggleBtn.textContent = "Open Editor";
    }
});

// ---------- Search Functionality ----------
const searchBar = document.getElementById("searchBar");
const searchResults = document.getElementById("searchResults");

searchBar.addEventListener("input", () => {
    const query = searchBar.value.toLowerCase();
    const results = pictoIndex.filter(p => 
        p.name.toLowerCase().includes(query) || 
        p.tags.some(tag => tag.includes(query))
    ).slice(0, 50); // only show first 50 results
    displaySearchResults(results);
});

function displaySearchResults(results) {
    searchResults.innerHTML = "";
    results.forEach(picto => {
        const img = document.createElement("img");
        img.src = picto.src;
        img.width = 80;
        img.alt = picto.name;
        img.draggable = true;
        img.addEventListener("dragstart", dragStartFromSearch);
        searchResults.appendChild(img);
    });
}

function dragStartFromSearch(e) {
    draggedItem = e.target;
    e.dataTransfer.setData("imageSrc", e.target.src);
}

// ---------- Drag & Drop for Planning ----------
const planning = document.getElementById("planning");

planning.addEventListener("dragover", e => e.preventDefault());
planning.addEventListener("drop", e => {
    e.preventDefault();
    if (!draggedItem) return;

    const img = draggedItem.cloneNode(true);
    img.draggable = true;
    planning.appendChild(img);
    savePlanning();
    draggedItem = null;
});

// ---------- Save & Load Planning (localStorage for simplicity) ----------
function savePlanning() {
    const images = [...planning.querySelectorAll("img")].map(img => img.src);
    localStorage.setItem("userPlanning", JSON.stringify(images));
}

function loadPlanning() {
    const stored = JSON.parse(localStorage.getItem("userPlanning") || "[]");
    stored.forEach(src => {
        const img = document.createElement("img");
        img.src = src;
        img.width = 80;
        img.draggable = true;
        planning.appendChild(img);
    });
}

loadPlanning();

// ---------- Reorder in Planning ----------
let movingImg = null;
planning.addEventListener("dragstart", e => {
    if (e.target.tagName === "IMG") movingImg = e.target;
});
planning.addEventListener("dragend", e => { movingImg = null; });
planning.addEventListener("dragover", e => e.preventDefault());
planning.addEventListener("drop", e => {
    if (!movingImg) return;
    const afterElement = getDragAfterElement(planning, e.clientX);
    if (afterElement == null) planning.appendChild(movingImg);
    else planning.insertBefore(movingImg, afterElement);
    savePlanning();
});

function getDragAfterElement(container, x) {
    const draggableElements = [...container.querySelectorAll("img:not(.dragging)")];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = x - box.left - box.width/2;
        if (offset < 0 && offset > closest.offset) return {offset: offset, element: child};
        return closest;
    }, {offset: Number.NEGATIVE_INFINITY}).element;
}
</script>

</body>
</html>
